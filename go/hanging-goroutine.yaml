rules:
- id: hanging-goroutine
  message: >-
    Potential goroutine leak due to unbuffered channel send inside loop or unbuffered channel receive in select block
  languages: [go]
  severity: ERROR
  metadata:
    category: security
    cwe: "CWE-833: Deadlock"
    subcategory: [vuln]
    confidence: MEDIUM
    likelihood: MEDIUM
    impact: LOW
    technology: [--no-technology--]
    description: "Goroutine leaks"
    references:
      - https://blog.trailofbits.com/2021/11/08/discovering-goroutine-leaks-with-semgrep

  patterns:
    - pattern-either: 
      - pattern: |
          for ... {
            ...
            go func(...) {
              ...
              $CHANNEL <- $VAL
              ...
            }(...)
          }
          ...
          $Y = <- $CHANNEL
          ...
      - pattern: |
          for ... {
            ...
            go func(...) {
              ...
              $CHANNEL <- $VAL
              ...
            }(...)
          }
          ...
          $Y := <- $CHANNEL
          ...
      - pattern: |
          for ... {
            ...
            go func(...) {
              ...
              $CHANNEL <- $VAL
              ...
            }(...)
          }
          ...
          return <- $CHANNEL
      - pattern: |
          for ... {
            ...
            go func(...) {
              ...
              select {
                case ...
                case $CHANNEL <- $VAL: ...
                case ...
              }
              ...
            }(...)
          ...
          }
          ...
          return <- $CHANNEL
      - pattern: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case $Y = <- $CHANNEL: 
          ...
          }
      - pattern: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case $Y := <- $CHANNEL: 
          ...
          }
      - pattern: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case <- $CHANNEL: 
          ...
          }
      - pattern: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case $Y <- $CHANNEL: 
          ...
          }
    - pattern-not: |
        for ... {
          ...
          go func(...) {
            ...
            $CHANNEL <- $VAL
            ...
          }(...)
        }
        ...
        $Y = <- $CHANNEL
        ...
    - pattern-inside: |
        $CHANNEL := make(...)
        ...
    - pattern-not-inside: |
        ...
        select {
        case ...
        case ...: 
          ...
          ... =<- $CHANNEL
          ...
        }
    - pattern-not-inside: |
        ...
        select {
        case ...
        case ...: 
          ...
          <-$CHANNEL
          ...
        }
    - pattern-not-inside: |
        $CHANNEL := make(..., $T)
        ...
