rules:
  - id: hanging-goroutine
    message: >-
      Potential goroutine leak due to unbuffered channel send inside loop or unbuffered channel receive in select block
    languages: [go]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-833: Deadlock"
      subcategory: [vuln]
      confidence: MEDIUM
      likelihood: MEDIUM
      impact: LOW
      technology: [--no-technology--]
      description: "Goroutine leaks"
      references:
        - https://blog.trailofbits.com/2021/11/08/discovering-goroutine-leaks-with-semgrep

    patterns:
      - pattern-either:
          - pattern: |
              for ... {
                ...
                go func(...) {
                  ...
                  $CHANNEL <- $VAL
                  ...
                }(...)
              }
              ...
              $Y = <- $CHANNEL
              ...
          - pattern: |
              for ... {
                ...
                go func(...) {
                  ...
                  $CHANNEL <- $VAL
                  ...
                }(...)
              }
              ...
              return <- $CHANNEL
          - pattern: |
              for ... {
                ...
                go func(...) {
                  ...
                  select {
                    case ...
                    case $CHANNEL <- $VAL: ...
                    case ...
                  }
                  ...
                }(...)
              ...
              }
              ...
              return <- $CHANNEL
          - pattern: |
              go func(...){
                ...
                $CHANNEL <- $X
                ...
              }(...)
              ...
              select {
              case ...
              case $Y = <- $CHANNEL: 
              ...
              }
          - pattern: |
              go func(...){
                ...
                $CHANNEL <- $X
                ...
              }(...)
              ...
              select {
              case ...
              case <- $CHANNEL: 
              ...
              }
          - pattern: |
              go func(...){
                ...
                $CHANNEL <- $X
                ...
              }(...)
              ...
              select {
              case ...
              case $Y <- $CHANNEL: 
              ...
              }
      - pattern-inside: |
          $CHANNEL := make(...)
          ...
      - pattern-not-inside: |
          $CHANNEL := make(..., $T)
          ...

      # heuristics to limit FPs, we may miss some leaks because of these
      - pattern-not: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case ...: 
            ...
            ... = <- $CHANNEL
            ...
          }
      - pattern-not: |
          go func(...){
            ...
            $CHANNEL <- $X
            ...
          }(...)
          ...
          select {
          case ...
          case ...: 
            ...
            <-$CHANNEL
            ...
          }
